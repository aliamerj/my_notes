# Working Code Isn‚Äôt Enough (Strategic vs. Tactical Programming)
This chapter explains the difference between tactical and strategic programming and why a strategic approach leads to better long-term outcomes. It highlights that just getting the code to work isn‚Äôt enough; you must also consider how maintainable and scalable it will be in the future.

## 3.1 Tactical Programming: A Short-Term Mindset
Tactical programming is all about getting things to work as quickly as possible. It‚Äôs often driven by deadlines and the pressure to ship features fast. The problem? It sacrifices long-term code quality.

- Developers take shortcuts‚Äîadding complexity, creating workarounds, or ignoring design issues‚Äîjust to meet immediate goals.
- Complexity builds up incrementally with every change, making the codebase harder to maintain over time.
- When problems arise, developers apply quick patches instead of proper fixes, creating even more complexity.
- This leads to a vicious cycle: the system becomes a mess, but cleaning it up takes too much time, so teams keep patching instead of fixing.

A common example of this is the "tactical tornado"‚Äîa developer who produces a lot of code quickly but leaves behind a disaster that others must clean up. While these developers might seem like heroes to management, their approach actually slows the entire team down in the long run.

## 3.2 Strategic Programming: Thinking Long-Term
Strategic programming means prioritizing good design alongside functionality. The goal isn‚Äôt just working code‚Äîit‚Äôs code that is easy to extend and maintain.

- You invest time upfront to find clean solutions, rather than rushing to the first workable one.
- You consider future changes, ensuring the design allows for flexibility.
- When you spot design flaws, you fix them early instead of ignoring them.

This mindset is an investment: it might slow down initial development by 10‚Äì20%, but it pays off quickly. After a few months, development speeds up because the system remains easy to work with.

## 3.3 How Much to Invest?
A huge up-front design effort (like the outdated "waterfall" approach) isn‚Äôt ideal. Instead, the best approach is continuous small investments:

- Spend 10‚Äì20% of your development time improving design and reducing complexity.
- This prevents the codebase from degrading, ensuring long-term speed and efficiency.
- If you neglect design, your development speed declines over time due to increasing complexity.

## 3.4 Startups and Investment
Startups often prioritize speed over code quality, assuming they can "fix it later" once they succeed. However, this rarely works:

- Facebook initially followed a tactical approach with its "Move fast and break things" motto. Over time, they realized their codebase had become too unstable and changed their philosophy to ‚ÄúMove fast with solid infrastructure.‚Äù
- Google and VMware, on the other hand, invested in high-quality design from the start, which helped them attract top engineers and scale more effectively.

These examples show that both approaches can succeed, but working in a company that values good design is much more enjoyable.

## 3.5 Conclusion: Invest Today, Not Tomorrow
- Good design requires continuous investment to prevent small issues from growing into major problems.
- Strategic programming pays for itself quickly‚Äîcleaner code means faster development in the long run.
- If you delay fixing design problems, you risk falling into a permanent tactical mindset, where complexity accumulates and productivity suffers.
- Every developer should make small improvements consistently, rather than waiting for a "perfect time" to clean things up.

### The key takeaway? Don‚Äôt just write code that works. Write code that lasts. üöÄ
