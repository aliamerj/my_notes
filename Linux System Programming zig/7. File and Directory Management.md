## What is Metadata?
Metadata is data about a file that describes its properties, but it doesn't include the file's actual content. For example:
- Size of the file (in bytes)
- File type (e.g., regular file, directory, or symbolic link)
- Access permissions (e.g., readable, writable, executable)
- Owner and group IDs (to track who owns the file)
- Last modified or accessed time (timestamps)
Think of metadata as a file's profile information that tells you everything about the file, except what's inside it.

## Inodes
Every file on a Unix-like filesystem is associated with an inode (short for "index node").
- An inode is a data structure on disk and in memory.
- It contains metadata about the file (like permissions, size, owner).
- It doesn't store the file's name. Instead, the file name is stored in the directory entry, which links to the inode.
Each file has a unique inode number within its filesystem. For example:

```bash
$ ls -i
12345 example.txt
```
The number 12345 is the inode number.

## How to Work with Metadata in Linux
To access metadata, Unix provides a set of system calls:
- stat: Fetches metadata for a file specified by its path.
- fstat: Fetches metadata for a file represented by a file descriptor.
- lstat: Similar to stat, but works on symbolic links themselves instead of their targets.

### Implementing stat in Zig
Here's how to use stat to get metadata for a file in Zig:

Code Example: Fetching File Metadata
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    // File path to analyze
    const file_path = "example.txt";

    var stat_buf: std.fs.Stat = undefined;

    // Open the file
    const file = try std.fs.cwd().openFile(file_path, .{ .read = true });
    defer file.close();

    // Fetch the metadata
    stat_buf = try file.getStat();

    // Print file size
    std.debug.print("File: {s}\n", .{file_path});
    std.debug.print("Size: {d} bytes\n", .{stat_buf.size});
    std.debug.print("Last Access Time: {s}\n", .{stat_buf.atime.toString()});
    std.debug.print("Last Modification Time: {s}\n", .{stat_buf.mtime.toString()});
    std.debug.print("Permissions: {s}\n", .{stat_buf.mode.toString()});
}
```

##### Explanation:
1. Inode Access in Zig: The std.fs.Stat struct gives access to all metadata:
   - size: File size in bytes.
   - atime: Last accessed time.
   - mtime: Last modified time.
   - mode: Access permissions.
2. File Opening:
- We open the file using std.fs.cwd().openFile() to get a handle.

3. Fetching Metadata:
- Call file.getStat() to fetch the metadata and populate the std.fs.Stat structure.
4. Output:
- The code prints the metadata (e.g., size, timestamps, and permissions).

### Hard and Symbolic Links in Linux Filesystems
#### Concept 1: What are Hard Links?
A hard link is a direct pointer to the same inode as the original file. It effectively creates another name for the same file.

#### Key points:
- Both the original file and the hard link share the same inode number.
- Changes to the file content will be reflected in all hard links pointing to it because they reference the same data blocks.
- Deleting one hard link does not remove the file data as long as there’s at least one link remaining.
- Hard links cannot span across filesystems because they rely on inode numbers, which are unique only within a single filesystem.
Example:
In the terminal:
```bash
$ echo "Hello World" > original.txt
$ ln original.txt hardlink.txt
$ ls -li
12345 -rw-r--r--  2 user group 12 Dec 9 14:22 hardlink.txt
12345 -rw-r--r--  2 user group 12 Dec 9 14:22 original.txt
```
Here:
- Both files share the same inode (12345).
- The 2 under the hard link count shows that the inode is now referenced by two files.

#### Concept 2: What are Symbolic Links?
A symbolic link (symlink) is a special file that points to the path of another file.

#### Key points:
- A symlink is a separate inode and does not share the original file’s inode.
- It is essentially a shortcut and does not contain the actual data.
- If the target file is deleted, the symlink becomes broken (dangling link).
- Symlinks can span across different filesystems.
Example:
In the terminal:

```bash
$ ln -s original.txt symlink.txt
$ ls -li
12345 -rw-r--r--  1 user group 12 Dec 9 14:22 original.txt
54321 lrwxrwxrwx  1 user group 12 Dec 9 14:23 symlink.txt -> original.txt
```
Here:
- symlink.txt is a separate file with its own inode (54321).
- It points to original.txt, but does not share its content.

##### Let's Implement This in Zig!
1. Hard Links Example in Zig
This example demonstrates creating a hard link using Zig:

```zig
const std = @import("std");

pub fn main() !void {
    const original = "original.txt";
    const hardlink = "hardlink.txt";

    // Open the filesystem for operations
    const fs = std.fs.cwd();

    // Create a test file
    try fs.createFile(original).close();

    // Create a hard link
    try fs.link(original, hardlink);

    // Display success message
    std.debug.print("Hard link created: {s} -> {s}\n", .{hardlink, original});
}
```
- fs.link(original, hardlink): This creates a hard link.
- If you inspect with ls -li, both files will share the same inode.

#### Symbolic Links Example in Zig
This example demonstrates creating a symbolic link:

```zig
const std = @import("std");

pub fn main() !void {
    const original = "original.txt";
    const symlink = "symlink.txt";

    // Open the filesystem for operations
    const fs = std.fs.cwd();

    // Create a test file
    try fs.createFile(original).close();

    // Create a symbolic link
    try fs.symlink(original, symlink);

    // Display success message
    std.debug.print("Symbolic link created: {s} -> {s}\n", .{symlink, original});
}
```
- fs.symlink(original, symlink): This creates a symbolic link.
- If the target file (original.txt) is deleted, symlink.txt becomes a dangling link.

### Extended Attributes 
#### What are Extended Attributes (xattrs)?
- Extended attributes are like tags you can attach to files. Imagine a sticky note where you can write extra information (key/value pairs) about the file, which is not part of the file content itself.
- They are used to store metadata like file type, author, or custom application-specific data.
- Applications interact with xattrs using a common API, regardless of the underlying filesystem. However, the filesystem must support xattrs (e.g., ext4 does; FAT32 does not).

#### Key Components
- Keys: Unique identifiers for the data. Example: user.mime_type.
- Values: The data associated with a key. It can be binary or text.
- Namespaces: Organize attributes (e.g., user, system, security, trusted).

1. Checking if xattrs are Supported
Before working with xattrs, it's useful to confirm if the filesystem supports them. Filesystems like ext4 generally do, but not all do.

Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        "user.test_key",
        "test_value",
        10,
        0
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        if (errno == @import("libc").ENOTSUP) {
            std.debug.print("Extended attributes are not supported on this filesystem.\n", .{});
        } else {
            std.debug.print("Failed to set extended attribute. Errno: {d}\n", .{errno});
        }
    } else {
        std.debug.print("Extended attributes are supported!\n", .{});
    }
}
```
2. Retrieving an Extended Attribute
To retrieve an xattr, we need:
- File Path: The file we are querying.
- Key: The specific attribute we want.
If the attribute exists, we get its value; otherwise, an error is returned.

Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    // Assign an xattr for demonstration
    const set_result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        "user.demo_key",
        "demo_value",
        10,
        0
    ));
    if (set_result == -1) {
        std.debug.print("Failed to set xattr. Ensure your filesystem supports it.\n", .{});
        return;
    }

    // Retrieve the size of the xattr
    const attr_size = @intCast(isize, @import("libc").getxattr(
        "test_file.txt",
        "user.demo_key",
        null,
        0
    ));

    if (attr_size == -1) {
        std.debug.print("xattr retrieval failed.\n", .{});
        return;
    }

    // Allocate buffer for the xattr value
    var buffer = try allocator.alloc(u8, attr_size);

    // Fetch the xattr value
    const value_size = @intCast(isize, @import("libc").getxattr(
        "test_file.txt",
        "user.demo_key",
        buffer.ptr,
        attr_size
    ));

    if (value_size == -1) {
        std.debug.print("Failed to read xattr value.\n", .{});
        return;
    }

    std.debug.print("Retrieved xattr value: {s}\n", .{buffer.ptr[0..attr_size]});
}
```

3. Setting an Extended Attribute
To set an xattr, you need:
- File Path: The target file.
- Key: The name of the attribute.
- Value: The data you want to store.
- Flags: Controls behavior (e.g., create only if the key doesn’t exist).
Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const key = "user.custom_key";
    const value = "custom_value";

    const result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        key,
        value,
        @sizeOf(@TypeOf(value)),
        0 // No specific flags
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        std.debug.print("Failed to set xattr. Errno: {d}\n", .{errno});
    } else {
        std.debug.print("Successfully set xattr: {s} = {s}\n", .{key, value});
    }
}
```

4. Deleting an Extended Attribute
To remove an xattr:
- Specify the file and the key.

If the key doesn’t exist, an error occurs.
Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const key = "user.custom_key";

    const result = @intCast(isize, @import("libc").removexattr(
        "test_file.txt",
        key
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        std.debug.print("Failed to remove xattr. Errno: {d}\n", .{errno});
    } else {
        std.debug.print("Successfully removed xattr: {s}\n", .{key});
    }
}
```
