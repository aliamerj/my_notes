## What is Metadata?
Metadata is data about a file that describes its properties, but it doesn't include the file's actual content. For example:
- Size of the file (in bytes)
- File type (e.g., regular file, directory, or symbolic link)
- Access permissions (e.g., readable, writable, executable)
- Owner and group IDs (to track who owns the file)
- Last modified or accessed time (timestamps)
Think of metadata as a file's profile information that tells you everything about the file, except what's inside it.

## Inodes
Every file on a Unix-like filesystem is associated with an inode (short for "index node").
- An inode is a data structure on disk and in memory.
- It contains metadata about the file (like permissions, size, owner).
- It doesn't store the file's name. Instead, the file name is stored in the directory entry, which links to the inode.
Each file has a unique inode number within its filesystem. For example:

```bash
$ ls -i
12345 example.txt
```
The number 12345 is the inode number.

## How to Work with Metadata in Linux
To access metadata, Unix provides a set of system calls:
- stat: Fetches metadata for a file specified by its path.
- fstat: Fetches metadata for a file represented by a file descriptor.
- lstat: Similar to stat, but works on symbolic links themselves instead of their targets.

### Implementing stat in Zig
Here's how to use stat to get metadata for a file in Zig:

Code Example: Fetching File Metadata
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    // File path to analyze
    const file_path = "example.txt";

    var stat_buf: std.fs.Stat = undefined;

    // Open the file
    const file = try std.fs.cwd().openFile(file_path, .{ .read = true });
    defer file.close();

    // Fetch the metadata
    stat_buf = try file.getStat();

    // Print file size
    std.debug.print("File: {s}\n", .{file_path});
    std.debug.print("Size: {d} bytes\n", .{stat_buf.size});
    std.debug.print("Last Access Time: {s}\n", .{stat_buf.atime.toString()});
    std.debug.print("Last Modification Time: {s}\n", .{stat_buf.mtime.toString()});
    std.debug.print("Permissions: {s}\n", .{stat_buf.mode.toString()});
}
```

##### Explanation:
1. Inode Access in Zig: The std.fs.Stat struct gives access to all metadata:
   - size: File size in bytes.
   - atime: Last accessed time.
   - mtime: Last modified time.
   - mode: Access permissions.
2. File Opening:
- We open the file using std.fs.cwd().openFile() to get a handle.

3. Fetching Metadata:
- Call file.getStat() to fetch the metadata and populate the std.fs.Stat structure.
4. Output:
- The code prints the metadata (e.g., size, timestamps, and permissions).

### Hard and Symbolic Links in Linux Filesystems
#### Concept 1: What are Hard Links?
A hard link is a direct pointer to the same inode as the original file. It effectively creates another name for the same file.

#### Key points:
- Both the original file and the hard link share the same inode number.
- Changes to the file content will be reflected in all hard links pointing to it because they reference the same data blocks.
- Deleting one hard link does not remove the file data as long as there’s at least one link remaining.
- Hard links cannot span across filesystems because they rely on inode numbers, which are unique only within a single filesystem.
Example:
In the terminal:
```bash
$ echo "Hello World" > original.txt
$ ln original.txt hardlink.txt
$ ls -li
12345 -rw-r--r--  2 user group 12 Dec 9 14:22 hardlink.txt
12345 -rw-r--r--  2 user group 12 Dec 9 14:22 original.txt
```
Here:
- Both files share the same inode (12345).
- The 2 under the hard link count shows that the inode is now referenced by two files.

#### Concept 2: What are Symbolic Links?
A symbolic link (symlink) is a special file that points to the path of another file.

#### Key points:
- A symlink is a separate inode and does not share the original file’s inode.
- It is essentially a shortcut and does not contain the actual data.
- If the target file is deleted, the symlink becomes broken (dangling link).
- Symlinks can span across different filesystems.
Example:
In the terminal:

```bash
$ ln -s original.txt symlink.txt
$ ls -li
12345 -rw-r--r--  1 user group 12 Dec 9 14:22 original.txt
54321 lrwxrwxrwx  1 user group 12 Dec 9 14:23 symlink.txt -> original.txt
```
Here:
- symlink.txt is a separate file with its own inode (54321).
- It points to original.txt, but does not share its content.

##### Let's Implement This in Zig!
1. Hard Links Example in Zig
This example demonstrates creating a hard link using Zig:

```zig
const std = @import("std");

pub fn main() !void {
    const original = "original.txt";
    const hardlink = "hardlink.txt";

    // Open the filesystem for operations
    const fs = std.fs.cwd();

    // Create a test file
    try fs.createFile(original).close();

    // Create a hard link
    try fs.link(original, hardlink);

    // Display success message
    std.debug.print("Hard link created: {s} -> {s}\n", .{hardlink, original});
}
```
- fs.link(original, hardlink): This creates a hard link.
- If you inspect with ls -li, both files will share the same inode.

#### Symbolic Links Example in Zig
This example demonstrates creating a symbolic link:

```zig
const std = @import("std");

pub fn main() !void {
    const original = "original.txt";
    const symlink = "symlink.txt";

    // Open the filesystem for operations
    const fs = std.fs.cwd();

    // Create a test file
    try fs.createFile(original).close();

    // Create a symbolic link
    try fs.symlink(original, symlink);

    // Display success message
    std.debug.print("Symbolic link created: {s} -> {s}\n", .{symlink, original});
}
```
- fs.symlink(original, symlink): This creates a symbolic link.
- If the target file (original.txt) is deleted, symlink.txt becomes a dangling link.

### Extended Attributes 
#### What are Extended Attributes (xattrs)?
- Extended attributes are like tags you can attach to files. Imagine a sticky note where you can write extra information (key/value pairs) about the file, which is not part of the file content itself.
- They are used to store metadata like file type, author, or custom application-specific data.
- Applications interact with xattrs using a common API, regardless of the underlying filesystem. However, the filesystem must support xattrs (e.g., ext4 does; FAT32 does not).

#### Key Components
- Keys: Unique identifiers for the data. Example: user.mime_type.
- Values: The data associated with a key. It can be binary or text.
- Namespaces: Organize attributes (e.g., user, system, security, trusted).

1. Checking if xattrs are Supported
Before working with xattrs, it's useful to confirm if the filesystem supports them. Filesystems like ext4 generally do, but not all do.

Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        "user.test_key",
        "test_value",
        10,
        0
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        if (errno == @import("libc").ENOTSUP) {
            std.debug.print("Extended attributes are not supported on this filesystem.\n", .{});
        } else {
            std.debug.print("Failed to set extended attribute. Errno: {d}\n", .{errno});
        }
    } else {
        std.debug.print("Extended attributes are supported!\n", .{});
    }
}
```
2. Retrieving an Extended Attribute
To retrieve an xattr, we need:
- File Path: The file we are querying.
- Key: The specific attribute we want.
If the attribute exists, we get its value; otherwise, an error is returned.

Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const allocator = std.heap.page_allocator;

    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    // Assign an xattr for demonstration
    const set_result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        "user.demo_key",
        "demo_value",
        10,
        0
    ));
    if (set_result == -1) {
        std.debug.print("Failed to set xattr. Ensure your filesystem supports it.\n", .{});
        return;
    }

    // Retrieve the size of the xattr
    const attr_size = @intCast(isize, @import("libc").getxattr(
        "test_file.txt",
        "user.demo_key",
        null,
        0
    ));

    if (attr_size == -1) {
        std.debug.print("xattr retrieval failed.\n", .{});
        return;
    }

    // Allocate buffer for the xattr value
    var buffer = try allocator.alloc(u8, attr_size);

    // Fetch the xattr value
    const value_size = @intCast(isize, @import("libc").getxattr(
        "test_file.txt",
        "user.demo_key",
        buffer.ptr,
        attr_size
    ));

    if (value_size == -1) {
        std.debug.print("Failed to read xattr value.\n", .{});
        return;
    }

    std.debug.print("Retrieved xattr value: {s}\n", .{buffer.ptr[0..attr_size]});
}
```

3. Setting an Extended Attribute
To set an xattr, you need:
- File Path: The target file.
- Key: The name of the attribute.
- Value: The data you want to store.
- Flags: Controls behavior (e.g., create only if the key doesn’t exist).
Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const key = "user.custom_key";
    const value = "custom_value";

    const result = @intCast(isize, @import("libc").setxattr(
        "test_file.txt",
        key,
        value,
        @sizeOf(@TypeOf(value)),
        0 // No specific flags
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        std.debug.print("Failed to set xattr. Errno: {d}\n", .{errno});
    } else {
        std.debug.print("Successfully set xattr: {s} = {s}\n", .{key, value});
    }
}
```

4. Deleting an Extended Attribute
To remove an xattr:
- Specify the file and the key.

If the key doesn’t exist, an error occurs.
Zig Code Example
```zig
const std = @import("std");

pub fn main() !void {
    const file = try std.fs.cwd().createFile("test_file.txt", .{});
    defer file.close();

    const key = "user.custom_key";

    const result = @intCast(isize, @import("libc").removexattr(
        "test_file.txt",
        key
    ));

    if (result == -1) {
        const errno = @import("libc").errno();
        std.debug.print("Failed to remove xattr. Errno: {d}\n", .{errno});
    } else {
        std.debug.print("Successfully removed xattr: {s}\n", .{key});
    }
}
```
## Directories
In Unix, a directory is essentially a container that holds a list of filenames. These filenames map to inode numbers, which are used by the system to locate the actual data on the device.

Here's a breakdown of the important points:

1. Directory Entries and Inodes:
- A directory contains directory entries. Each directory entry is a filename that is linked to an inode number.
- An inode is a data structure that stores information about a file, except its name and its data (such as file size, permissions, timestamps, and location on disk).

2. Directories and Subdirectories:
- Directories can contain other directories. These are called subdirectories.
- For example, in a path like /home/user/docs/, the /home/user/ directory contains a subdirectory called docs.

3. The Root Directory:
- The root directory is the top-level directory in the filesystem hierarchy. It is represented by / and contains all other directories.
- All other directories, except the root, are subdirectories of some parent directory.

4. Pathnames:
- A pathname refers to a file or directory and includes the directory names leading up to the file. It can be absolute or relative.
- An absolute pathname starts from the root directory (e.g., /usr/bin/sextant).
- A relative pathname does not start from the root directory and depends on the current working directory (e.g., bin/sextant).

5. Dot (.) and Dot-dot (..) Directories:
- Every directory contains two special directory entries: . (dot) and .. (dot-dot).
- `.` refers to the directory itself.
- `..` refers to the parent directory of the current directory.
For example, /home/user/docs/.. is the same as /home/user/.

### Creating Directories
In Linux and Unix-like systems, the creation of directories is handled through the mkdir() system call. A directory in a filesystem is a special file that holds filenames and their associated inode numbers, essentially providing a way to organize files in a hierarchical structure.

- path: This is the pathname of the directory that you want to create. It can be either a relative or an absolute pathname.
- mode: This is a permission mask (a set of flags) that determines the access rights for the new directory. These permissions are specified using octal values, with each bit representing a different permission. The most common permissions are:
- S_IRUSR (read permission for the owner)
- S_IWUSR (write permission for the owner)
- S_IXUSR (execute/search permission for the owner)
- S_IRGRP, S_IWGRP, S_IXGRP for the group
- S_IROTH, S_IWOTH, S_IXOTH for others
Example:

```c
#include <sys/stat.h>
#include <sys/types.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    const char *dir_name = "example_directory";
    int ret = mkdir(dir_name, 0755); // 0755 gives full read, write, and execute permissions to the owner, and read and execute permissions to others.

    if (ret == -1) {
        perror("mkdir failed");
        exit(EXIT_FAILURE);
    }

    printf("Directory '%s' created successfully\n", dir_name);
    return 0;
}
```
Explanation of mkdir() call:

- If mkdir() is successful, it returns 0, creating the directory with the specified name and permissions.
- If it fails, it returns -1 and sets the errno variable to indicate the error, such as EEXIST (directory already exists), EACCES (no permission), or ENAMETOOLONG (the directory name is too long).

### Why the mode argument is important:
The mode specifies the permissions for the newly created directory. For example:
- 0755 means that the owner of the directory has full permissions (read, write, and execute), while others have only read and execute permissions.
- The operating system’s umask (user file creation mask) further modifies these permissions. The umask is a mask applied to file creation permissions to exclude certain permissions.

For example, if the current umask is 0022, it would automatically subtract write permissions from the group and others when creating a directory. If you attempt to create a directory with the mkdir() call, and the umask modifies the requested permissions, the actual permissions may be different from what you specified.

### Common Errors in mkdir():
- EEXIST: The directory already exists.
- EACCES: Permission denied for creating the directory (you don't have the necessary access).
- ENOSPC: No space left on the device to create the directory.
- ENAMETOOLONG: The directory name exceeds the maximum length allowed.
Important Note: When you create a directory, it doesn't automatically create parent directories if they don't exist. If you need to create parent directories as well, you can either manually create them first or use the -p option in the shell (for example, mkdir -p /parent/child). The mkdir() system call in C does not have an equivalent to this, so you would need to write additional code to handle parent directories.

### Removing Directories
To remove directories in Linux and Unix-like systems, the rmdir() function is used. It is the counterpart to the mkdir() function, which creates directories. The rmdir() function removes an empty directory from the filesystem.
- path: This is the directory to be removed. It must be empty, except for the . (dot) and .. (dot-dot) directories, which are required for directory navigation.
#### Return Value:
- On Success: rmdir() returns 0, indicating that the directory has been successfully removed.
- On Failure: rmdir() returns -1 and sets errno to one of the following error codes:
#### Common Error Codes for rmdir():
- EACCES: The process does not have write access to the parent directory, or one of the directories in the path is not searchable.
- EBUSY: The directory is currently in use (e.g., it is a mount point).
- EFAULT: Invalid memory reference for path.
- EINVAL: The directory path ends with . (dot).
- ELOOP: Too many symbolic links encountered while resolving the path.
- ENAMETOOLONG: The path exceeds the system’s limit for directory name length.
- ENOENT: One or more components in the path does not exist, or the path is a dangling symbolic link.
- ENOMEM: Insufficient kernel memory to complete the request.
- ENOTDIR: One or more components in the path is not a directory.
- ENOTEMPTY: The directory is not empty and contains entries other than . and ...
- EPERM: The process does not have permission to remove the directory due to the sticky bit or filesystem restrictions.
- EROFS: The filesystem containing the directory is read-only.

### Reading a Directory's Contents
To read the contents of a directory, the POSIX standard provides a set of functions that allow a program to obtain a list of files in a given directory. These functions are useful for tasks such as implementing a file listing tool (e.g., ls), searching for files that match a pattern, or operating on all files in a directory.

#### Opening a Directory Stream:
To begin reading the contents of a directory, you need to create a directory stream using the opendir() function. The directory stream represents the directory that you will be reading from.
- name: The path to the directory you want to open.
##### Return Value:
- On success: Returns a pointer to a DIR object (a directory stream).
- On failure: Returns NULL, and errno is set to indicate the error.

#### Reading from a Directory Stream:
Once you have a directory stream, you can use the readdir() function to read the contents of the directory. Each call to readdir() returns the next directory entry.

```c
#include <sys/types.h>
#include <dirent.h>

struct dirent *readdir(DIR *dir);
```
##### Return Value:
- On success: Returns a pointer to a struct dirent, which contains information about the directory entry.
- On failure: Returns NULL. You can check errno to distinguish between an error and the end of the directory entries.
##### struct dirent:
The struct dirent contains metadata about a directory entry. It includes the following fields:
```c
struct dirent {
    ino_t d_ino;           /* inode number */
    off_t d_off;           /* offset to next dirent */
    unsigned short d_reclen; /* length of this record */
    unsigned char d_type;  /* type of file */
    char d_name[256];      /* filename */
};
```
- d_name: The name of the file or directory (this is the only field that is strictly required by POSIX).
- d_ino: The inode number of the file or directory.
- d_type: The type of file (e.g., directory, regular file, symbolic link).
- d_reclen and d_off: These are implementation-specific fields, useful when working with the underlying filesystem.

Example Code for Reading Directory Contents:
Here’s a function find_file_in_dir() that searches for a file in a directory using readdir():

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <dirent.h>
#include <errno.h>

int find_file_in_dir(const char *path, const char *file) {
    DIR *dir = opendir(path);
    if (dir == NULL) {
        perror("opendir failed");
        return 1;
    }

    struct dirent *entry;
    int ret = 1; // Default return value, assuming file is not found
    errno = 0;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, file) == 0) {
            ret = 0; // File found
            break;
        }
    }

    if (errno && entry == NULL) {
        perror("readdir failed");
    }

    closedir(dir);
    return ret;
}
```
#### Closing the Directory Stream:
Once you're done reading from a directory, you should close the directory stream using closedir():

```c
#include <sys/types.h>
#include <dirent.h>

int closedir(DIR *dir);
```
##### Return Value:
- On success: Returns 0.
- On failure: Returns -1 and sets errno to EBADF, indicating that dir is not a valid directory stream.
##### System Calls for Reading Directory Contents
While opendir(), readdir(), and closedir() are the standard POSIX library functions for reading directory contents, internally, they rely on system calls like readdir() and getdents(). These system calls provide lower-level access to directory entries.
- readdir(): Reads a directory entry from a directory stream.
- getdents(): A system call that provides the details of a directory's entries. It is more low-level and not recommended for user-space applications due to its complexity.

###### Example of readdir() System Call:
```c
#include <unistd.h>
#include <linux/types.h>
#include <linux/dirent.h>
```

- int readdir(unsigned int fd, struct dirent *dirp, unsigned int count);
- fd: The file descriptor for the directory.
- dirp: A pointer to a buffer that will hold the directory entry.
- count: The number of bytes to read from the directory.

##### Conclusion
- Removing directories: Use rmdir() to remove empty directories. It requires the directory to be empty (except for the dot directories) and will return an error if the directory is not empty or if there are other issues.
- Reading directories: To read a directory's contents, use opendir(), readdir(), and closedir(). These functions provide a simple interface for traversing directories in C. The dirent structure holds details about each entry in the directory, which can be processed or filtered as needed.
